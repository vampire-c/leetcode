package leetcode.everyday;

class Solution0191 {
/*

n=180
00000000000000000000000000 10110100 (180)

n>>>1
0b000000000000000000000000 01011010 (90)
0b010101010101010101010101 01010101 (0x55555555)

n>>>1 & 0x55555555
0b000000000000000000000000 01010000 (80)

n - ((n >>> 1) & 0x55555555)
0b000000000000000000000000 10110100 (180)
0b000000000000000000000000 01010000 (80)
0b000000000000000000000000 01100100 (100)

n & 0x33333333
0b000000000000000000000000 01100100 (100)
0b001100110011001100110011 00110011 (0x33333333)
00000000000000000000000000 00100000 (32)

(n >>> 2) & 0x33333333
0b000000000000000000000000 00011001 (100)
0b001100110011001100110011 00110011 (0x33333333)
0b000000000000000000000000 00010001 (17)

(n & 0x33333333)+((n >>> 2) & 0x33333333)
0b000000000000000000000000 00100000 (32)
0b000000000000000000000000 00010001 (17)
0b000000000000000000000000 00110001 (49)

(n + (n >>> 4)) & 0x0f0f0f0f
0b000000000000000000000000 00110001 (49)
0b000000000000000000000000 00000011 (3)
0b000000000000000000000000 00110100 (54)
0b000011110000111100001111 00001111 (0x0f0f0f0f)
0b000000000000000000000000 00000100 (4)

n + (n >>> 8)
0b000000000000000000000000 00000100 (4)
0b000000000000000000000000 00000000 (0)
0b000000000000000000000000 00000100 (4)

n + (n >>> 16)
0b000000000000000000000000 00000100 (4)
0b000000000000000000000000 00000000 (0)
0b000000000000000000000000 00000100 (4)

n & 0x3f
0b000000000000000000000000 00000100 (4)
0b000000000000000000000000 00111111 (0x3f)
0b000000000000000000000000 00000100 (4)

*/
    static void main(String[] args) {
        new Solution0191().hammingWeight(11);

        // System.out.println(Integer.toBinaryString(0x55555555));
        // System.out.println(Integer.toBinaryString(0x33333333));
        // System.out.println(Integer.toBinaryString(0x0f0f0f0f));
        // System.out.println(Integer.toBinaryString(0x00ff00ff));
        // System.out.println(Integer.toBinaryString(0x0000ffff));

        /*

        01010101010101010101010101010101
        00110011001100110011001100110011
        00001111000011110000111100001111
        00000000111111110000000011111111
        00000000000000001111111111111111

        */

        System.out.println(Integer.toBinaryString(0x55555555));
        // 01010101010101010101010101010101
        System.out.println(Integer.toBinaryString(0xaaaaaaaa));
        // 10101010101010101010101010101010

    }

    public int hammingWeight(int n) {
        n = n - ((n >>> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
        n = (n + (n >>> 4)) & 0x0f0f0f0f;
        n = n + (n >>> 8);
        n = n + (n >>> 16);
        return n & 0x3f;
    }

    public int hammingWeight1(int n) {
        String binaryString = Integer.toBinaryString(n);
        binaryString = binaryString.replaceAll("0", "");
        return binaryString.length();
    }


    public static int bitCount4(int n) {
        // 0xaaaaaaaa + 0x55555555 = 0xffffffff
        // n & 0xaaaaaaaa保留n中每相邻两位的高位
        // n & 0x55555555保留n中每相邻两位的低位
        n = (n & 0x55555555) + ((n & 0xaaaaaaaa) >>> 1);
        n = (n & 0x33333333) + ((n & 0xcccccccc) >>> 2);
        n = (n & 0x0f0f0f0f) + ((n & 0xf0f0f0f0) >>> 4);
        n = (n & 0x00ff00ff) + ((n & 0xff00ff00) >>> 8);
        n = (n & 0x0000ffff) + ((n & 0xffff0000) >>> 16);
        return n;
    }

    public static int bitCount5(int n) {
        // n & 0x55555555取n中每相邻两位的低位
        // (n>>>1) & 0x55555555取n中每相邻两位的高位
        n = (n & 0x55555555) + ((n >>> 1) & 0x55555555);//1
        n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);//2
        n = (n & 0x0f0f0f0f) + ((n >>> 4) & 0x0f0f0f0f);//3
        n = (n & 0x00ff00ff) + ((n >>> 8) & 0x00ff00ff);//4
        n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);//5
        return n;
    }


    public static int bitCount6(int n) {
        n = n - ((n >>> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
        n = (n + (n >>> 4)) & 0x0f0f0f0f;
        n = n + (n >>> 8);
        n = n + (n >>> 16);
        return n & 0x3f;
    }














}
